/*
 * Keycloak Admin REST API
 *
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`admin_realms_realm_users_count_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersCountGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_profile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersProfileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_profile_metadata_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersProfileMetadataGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_profile_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersProfilePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_configured_user_storage_credential_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_consents_client_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdConsentsClientDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_consents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdConsentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_credentials_credential_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_credentials_credential_id_move_after_new_previous_credential_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostError
{
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_credentials_credential_id_move_to_first_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_credentials_credential_id_user_label_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_credentials_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdCredentialsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_disable_credential_types_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdDisableCredentialTypesPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_execute_actions_email_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdExecuteActionsEmailPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_federated_identity_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdFederatedIdentityGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_federated_identity_provider_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_federated_identity_provider_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdFederatedIdentityProviderPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_groups_count_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdGroupsCountGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdGroupsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_groups_group_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdGroupsGroupIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_groups_group_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdGroupsGroupIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_impersonation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdImpersonationPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_logout_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdLogoutPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_offline_sessions_client_uuid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_reset_password_email_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdResetPasswordEmailPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_reset_password_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdResetPasswordPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_send_verify_email_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdSendVerifyEmailPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`admin_realms_realm_users_user_id_sessions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AdminRealmsRealmUsersUserIdSessionsGetError {
    UnknownValue(serde_json::Value),
}

/// It can be called in three different ways. 1. Donâ€™t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. <p> 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. <p> 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.
pub async fn admin_realms_realm_users_count_get(
    configuration: &configuration::Configuration,
    realm: &str,
    email: Option<&str>,
    email_verified: Option<bool>,
    enabled: Option<bool>,
    first_name: Option<&str>,
    last_name: Option<&str>,
    q: Option<&str>,
    search: Option<&str>,
    username: Option<&str>,
) -> Result<i32, Error<AdminRealmsRealmUsersCountGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/count",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = email {
        local_var_req_builder =
            local_var_req_builder.query(&[("email", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email_verified {
        local_var_req_builder =
            local_var_req_builder.query(&[("emailVerified", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enabled {
        local_var_req_builder =
            local_var_req_builder.query(&[("enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = first_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("firstName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("lastName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search {
        local_var_req_builder =
            local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = username {
        local_var_req_builder =
            local_var_req_builder.query(&[("username", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersCountGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_get(
    configuration: &configuration::Configuration,
    realm: &str,
    brief_representation: Option<bool>,
    email: Option<&str>,
    email_verified: Option<bool>,
    enabled: Option<bool>,
    exact: Option<bool>,
    first: Option<i32>,
    first_name: Option<&str>,
    idp_alias: Option<&str>,
    idp_user_id: Option<&str>,
    last_name: Option<&str>,
    max: Option<i32>,
    q: Option<&str>,
    search: Option<&str>,
    username: Option<&str>,
) -> Result<Vec<models::UserRepresentation>, Error<AdminRealmsRealmUsersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = brief_representation {
        local_var_req_builder =
            local_var_req_builder.query(&[("briefRepresentation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email {
        local_var_req_builder =
            local_var_req_builder.query(&[("email", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email_verified {
        local_var_req_builder =
            local_var_req_builder.query(&[("emailVerified", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enabled {
        local_var_req_builder =
            local_var_req_builder.query(&[("enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exact {
        local_var_req_builder =
            local_var_req_builder.query(&[("exact", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = first {
        local_var_req_builder =
            local_var_req_builder.query(&[("first", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = first_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("firstName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_alias {
        local_var_req_builder =
            local_var_req_builder.query(&[("idpAlias", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = idp_user_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("idpUserId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = last_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("lastName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search {
        local_var_req_builder =
            local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = username {
        local_var_req_builder =
            local_var_req_builder.query(&[("username", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_post(
    configuration: &configuration::Configuration,
    realm: &str,
    user_representation: Option<models::UserRepresentation>,
) -> Result<(), Error<AdminRealmsRealmUsersPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&user_representation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the configuration for the user profile
pub async fn admin_realms_realm_users_profile_get(
    configuration: &configuration::Configuration,
    realm: &str,
) -> Result<models::UpConfig, Error<AdminRealmsRealmUsersProfileGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/profile",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersProfileGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the UserProfileMetadata from the configuration
pub async fn admin_realms_realm_users_profile_metadata_get(
    configuration: &configuration::Configuration,
    realm: &str,
) -> Result<models::UserProfileMetadata, Error<AdminRealmsRealmUsersProfileMetadataGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/profile/metadata",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersProfileMetadataGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Set the configuration for the user profile
pub async fn admin_realms_realm_users_profile_put(
    configuration: &configuration::Configuration,
    realm: &str,
    up_config: Option<models::UpConfig>,
) -> Result<models::UpConfig, Error<AdminRealmsRealmUsersProfilePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/profile",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&up_config);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersProfilePutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returned values can contain for example \"password\", \"otp\" etc. This will always return empty list for \"local\" users, which are not backed by any user storage
pub async fn admin_realms_realm_users_user_id_configured_user_storage_credential_types_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<
    Vec<String>,
    Error<AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/configured-user-storage-credential-types",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<
            AdminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetError,
        > = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_consents_client_delete(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    client: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdConsentsClientDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/consents/{client}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        client = crate::apis::urlencode(client)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdConsentsClientDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_consents_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<
    Vec<std::collections::HashMap<String, serde_json::Value>>,
    Error<AdminRealmsRealmUsersUserIdConsentsGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/consents",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdConsentsGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_credentials_credential_id_delete(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    credential_id: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/credentials/{credentialId}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        credentialId = crate::apis::urlencode(credential_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<
            AdminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteError,
        > = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_credentials_credential_id_move_after_new_previous_credential_id_post(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    credential_id: &str,
    new_previous_credential_id: &str,
) -> Result<
    (),
    Error<
        AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostError,
    >,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/admin/realms/{realm}/users/{user_id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}", local_var_configuration.base_path, realm=crate::apis::urlencode(realm), user_id=crate::apis::urlencode(user_id), credentialId=crate::apis::urlencode(credential_id), newPreviousCredentialId=crate::apis::urlencode(new_previous_credential_id));
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_credentials_credential_id_move_to_first_post(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    credential_id: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/credentials/{credentialId}/moveToFirst",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        credentialId = crate::apis::urlencode(credential_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<
            AdminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostError,
        > = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_credentials_credential_id_user_label_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    credential_id: &str,
    body: Option<&str>,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/credentials/{credentialId}/userLabel",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        credentialId = crate::apis::urlencode(credential_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<
            AdminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutError,
        > = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_credentials_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<
    Vec<models::CredentialRepresentation>,
    Error<AdminRealmsRealmUsersUserIdCredentialsGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/credentials",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdCredentialsGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_delete(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_disable_credential_types_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    request_body: Option<Vec<String>>,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdDisableCredentialTypesPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/disable-credential-types",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdDisableCredentialTypesPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.
pub async fn admin_realms_realm_users_user_id_execute_actions_email_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    client_id: Option<&str>,
    lifespan: Option<i32>,
    redirect_uri: Option<&str>,
    request_body: Option<Vec<String>>,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdExecuteActionsEmailPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/execute-actions-email",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("client_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = lifespan {
        local_var_req_builder =
            local_var_req_builder.query(&[("lifespan", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = redirect_uri {
        local_var_req_builder =
            local_var_req_builder.query(&[("redirect_uri", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdExecuteActionsEmailPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_federated_identity_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<
    Vec<models::FederatedIdentityRepresentation>,
    Error<AdminRealmsRealmUsersUserIdFederatedIdentityGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/federated-identity",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdFederatedIdentityGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_federated_identity_provider_delete(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    provider: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/federated-identity/{provider}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        provider = crate::apis::urlencode(provider)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<
            AdminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteError,
        > = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_federated_identity_provider_post(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    provider: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdFederatedIdentityProviderPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/federated-identity/{provider}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        provider = crate::apis::urlencode(provider)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<
            AdminRealmsRealmUsersUserIdFederatedIdentityProviderPostError,
        > = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    user_profile_metadata: Option<bool>,
) -> Result<models::UserRepresentation, Error<AdminRealmsRealmUsersUserIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = user_profile_metadata {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProfileMetadata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_groups_count_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    search: Option<&str>,
) -> Result<
    std::collections::HashMap<String, i64>,
    Error<AdminRealmsRealmUsersUserIdGroupsCountGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/groups/count",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = search {
        local_var_req_builder =
            local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdGroupsCountGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_groups_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    brief_representation: Option<bool>,
    first: Option<i32>,
    max: Option<i32>,
    search: Option<&str>,
) -> Result<Vec<models::GroupRepresentation>, Error<AdminRealmsRealmUsersUserIdGroupsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/groups",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = brief_representation {
        local_var_req_builder =
            local_var_req_builder.query(&[("briefRepresentation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = first {
        local_var_req_builder =
            local_var_req_builder.query(&[("first", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = search {
        local_var_req_builder =
            local_var_req_builder.query(&[("search", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdGroupsGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_groups_group_id_delete(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    group_id: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdGroupsGroupIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/groups/{groupId}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        groupId = crate::apis::urlencode(group_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdGroupsGroupIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_groups_group_id_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    group_id: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdGroupsGroupIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/groups/{groupId}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        groupId = crate::apis::urlencode(group_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdGroupsGroupIdPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_impersonation_post(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<
    std::collections::HashMap<String, serde_json::Value>,
    Error<AdminRealmsRealmUsersUserIdImpersonationPostError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/impersonation",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdImpersonationPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_logout_post(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdLogoutPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/logout",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdLogoutPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_offline_sessions_client_uuid_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    client_uuid: &str,
) -> Result<
    Vec<models::UserSessionRepresentation>,
    Error<AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/offline-sessions/{clientUuid}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id),
        clientUuid = crate::apis::urlencode(client_uuid)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    user_representation: Option<models::UserRepresentation>,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&user_representation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The redirectUri and clientId parameters are optional. The default for the redirect is the account client. This endpoint has been deprecated.  Please use the execute-actions-email passing a list with UPDATE_PASSWORD within it.
pub async fn admin_realms_realm_users_user_id_reset_password_email_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    client_id: Option<&str>,
    redirect_uri: Option<&str>,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdResetPasswordEmailPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/reset-password-email",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("client_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = redirect_uri {
        local_var_req_builder =
            local_var_req_builder.query(&[("redirect_uri", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdResetPasswordEmailPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_reset_password_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    credential_representation: Option<models::CredentialRepresentation>,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdResetPasswordPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/reset-password",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&credential_representation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdResetPasswordPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours
pub async fn admin_realms_realm_users_user_id_send_verify_email_put(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
    client_id: Option<&str>,
    lifespan: Option<i32>,
    redirect_uri: Option<&str>,
) -> Result<(), Error<AdminRealmsRealmUsersUserIdSendVerifyEmailPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/send-verify-email",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("client_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = lifespan {
        local_var_req_builder =
            local_var_req_builder.query(&[("lifespan", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = redirect_uri {
        local_var_req_builder =
            local_var_req_builder.query(&[("redirect_uri", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdSendVerifyEmailPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn admin_realms_realm_users_user_id_sessions_get(
    configuration: &configuration::Configuration,
    realm: &str,
    user_id: &str,
) -> Result<
    Vec<models::UserSessionRepresentation>,
    Error<AdminRealmsRealmUsersUserIdSessionsGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/admin/realms/{realm}/users/{user_id}/sessions",
        local_var_configuration.base_path,
        realm = crate::apis::urlencode(realm),
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AdminRealmsRealmUsersUserIdSessionsGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
